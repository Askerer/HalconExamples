using System;
using System.Collections.Generic;
using System.Threading;
using HalconDotNet;

namespace HALCONActors
{
  public interface IHActor
  {
    void AddMessage(HMessage obj);
  }

  /// <summary>
  /// This general solution is based on two patterns:
  /// - the chain of responsibility pattern
  /// http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern
  /// - the actor model
  /// http://en.wikipedia.org/wiki/Actor_model
  ///
  /// It fits the use case where one needs several threads which cooperate with
  /// one another in that the output generated by one thread becomes the input
  /// for the next one (message passing in the actor model).
  ///
  /// A frequent case is the one where one or more threads grab images from cameras,
  /// and pass them on to one or more threads, which solve some image processing
  /// task and finally send the results to a UI thread responsible for displaying
  /// them (chain of responsibility pattern).
  /// </summary>
  public abstract class HActor : IHActor
  {
    protected bool running;
    private Thread worker;
    protected object locker;
    protected HMessageQueue msg_queue;
    private IHActor next;
    private bool wait;

    protected HMessage GenFinishMessage()
    {
      HMessage endmsg = new HMessage();
      endmsg.SetMessageTuple("finish_processing", 1);
      return endmsg;
    }

    public HActor(bool block)
    {
      msg_queue = new HMessageQueue();
      locker = new object();
      running = false;
      next = null;
      wait = block;
    }

    public HActor(IHActor destination, bool block)
    {
      msg_queue = new HMessageQueue();
      locker = new object();
      running = false;
      next = destination;
      wait = block;
    }

    public bool IsRunning
    {
      get
      {
        bool result;
        lock (locker)
          result = running;
        return result;
      }
    }

    public void AddMessage(HMessage obj)
    {
      msg_queue.EnqueueMessage(obj, new HTuple(""), new HTuple(""));
    }

    public IHActor Next
    {
      set
      {
        if (value == null)
          throw new ArgumentNullException();
        next = value;
      }
      get { return next; }
    }

    public abstract HMessage ActorTask(HMessage imsg);

    private void DoWork()
    {
      while (IsRunning)
      {
        HMessage imsg = null;
        if (wait)
          imsg = msg_queue.DequeueMessage("timeout", "infinite");
        else
        {
          try
          {
            // unless we post a message in the queue, we get a timeout
            // error
            imsg = msg_queue.DequeueMessage("timeout", 0);
          }
          catch (HalconException)
          {
          }
        }
        if (imsg != null)
        {
          HTuple finish = imsg.GetMessageParam("key_exists", "finish_processing");
          if ((int)finish == 1)
          {
            lock (locker)
              running = false;
            return;
          }
        }
        HMessage msg = ActorTask(imsg);
        if (Next != null)
          Next.AddMessage(msg);
      }
    }

    public void Start()
    {
      lock (locker)
        running = true;
      worker = new Thread(DoWork);
      worker.Start();
    }

    public void Stop()
    {
      if (IsRunning)
      {
        lock (locker)
          running = false;
        HTuple nmsg = msg_queue.GetMessageQueueParam("message_num");
        HTuple isempty = msg_queue.GetMessageQueueParam("is_empty");
        AddMessage(GenFinishMessage());
        nmsg = msg_queue.GetMessageQueueParam("message_num");
        isempty = msg_queue.GetMessageQueueParam("is_empty");
        worker.Join();
        msg_queue.SetMessageQueueParam("flush_queue", 1);
      }
    }
  }
}

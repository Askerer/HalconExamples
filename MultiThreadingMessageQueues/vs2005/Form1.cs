using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Windows.Forms;
using HalconDotNet;
using HALCONActors;

/*
 * Notice that the framegrabber uses an image sequence file, circle_plate.seq,
 * which is not part of the HALCON distribution, but is automatically generated by
 * Visual Studio before compilation. See under Project/Properties the Build Events
 * field.
 */

namespace HALCONDrawingObjects
{
    /// <summary>
    /// This example shows a template solution for a typical application, where
    /// images are acquired from one or more cameras, processed, and the results
    /// finally displayed in the window. The additional element is the use of
    /// drawing objects to specify the region in the image, where the image 
    /// processing is to be applied.
    /// 
    /// Also, the HALCON window does not offer the possibility of having a graphic
    /// stack that allows to pack as many objects as desired and then show them at once.
    /// This example shows how to easily add such a stack, and more importantly, how to
    /// perform the drawing within the UI thread. Concretely, refer to the method 
    /// DisplayResults() below.
    /// 
    /// </summary>
    public interface IHWindowGraphicStack
    {
        void DisplayResults();
        void AddToStack(HObject o);
        HDrawingObject GetCurrentDrawingObject();
    }

    public partial class HALCONDialog : Form, IHWindowGraphicStack, IHActor
    {
        private Stack<HObject> graphic_stack = new Stack<HObject>();
        private HDrawingObject roi_object;
        private object stack_lock = new object();
        private float width_ratio, height_ratio;
        private HObject dummy;

        private ImageGrabber imggrabber;
        private ShapeModelDisplay createsbm;
        private ShapeModelFinder findsbm;
        private HMessage dummy_msg;

        public HALCONDialog()
        {
            InitializeComponent();

            width_ratio = halconWindow.Width / (float)Width;
            height_ratio = halconWindow.Height / (float)Height;
            buttonRun.Location =
                new Point(buttonRun.Location.X,
                          halconWindow.Location.Y + halconWindow.Height + 10);
            buttonStop.Location =
                new Point(buttonStop.Location.X,
                          halconWindow.Location.Y + halconWindow.Height + 10);

            HOperatorSet.GenCrossContourXld(out dummy, -10, -10, 5, 0);
            halconWindow.HalconWindow.SetColor("green");
            halconWindow.HalconWindow.SetLineWidth(2);
            // Allow the shape model to be found when lying partly outside of the image
            HOperatorSet.SetSystem("border_shape_models", "true");

            //  the drawing object allows the user to dynamically select the ROI
            //  and see how it affects to the resulting shape based model
            roi_object = new HDrawingObject(350.0, 400.0, 0.0, 200.0, 100.0);
            HImage img = new HImage("metal-parts/circle_plate_01");
            HTuple width, height;
            img.GetImageSize(out width, out height);
            halconWindow.HalconWindow.SetPart(-1.0,-1.0,height-1,width-1);
            delayCheckBox.Checked = true;

            dummy_msg = new HMessage();
            HOperatorSet.GenEmptyObj(out dummy);
            dummy_msg.SetMessageObj(dummy, "dummy");
            // this example emulates the case where one continuously grabs images
            // in order to adapt the camera parameters so that the image processing
            // works properly. In this case, the framegrabber acquires the same image
            // continuously.
            createsbm = new ShapeModelDisplay("metal-parts/circle_plate_01", roi_object, this);
            createsbm.Start();

            roi_object.OnAttach(DefineShapeBasedModel);
            roi_object.OnDrag(DefineShapeBasedModel);
            roi_object.OnResize(DefineShapeBasedModel);
            halconWindow.HalconWindow.AttachDrawingObjectToWindow(roi_object);
            halconWindow.HalconWindow.SetColor("green");

            //  initialize the chain of responsibility pattern
            findsbm = new ShapeModelFinder(this);
            imggrabber = new ImageGrabber("circle_plate.seq", findsbm);
        }

        /// <summary>
        /// Triggers the image processing thread
        /// </summary>
        private void DefineShapeBasedModel(HDrawingObject drawid, HWindow window, string type)
        {
            if (buttonRun.Enabled)
                createsbm.AddMessage(dummy_msg);
        }

        /// <summary>
        /// Usually, image processing tasks may take a long time in terms of responsiveness.
        /// One way to overcome this problem is run the callback in a separate thread,
        /// and run the task only when the user is not interacting with the drawing object.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void halconWindow_HMouseUp(object sender, HMouseEventArgs e)
        {
            if (buttonRun.Enabled)
                createsbm.AddMessage(dummy_msg);
        }

        private void DisplayGraphicStack()
        {
            lock (stack_lock)
            {
                halconWindow.HalconWindow.ClearWindow();
                while (graphic_stack.Count > 0)
                {
                    halconWindow.HalconWindow.DispObj(graphic_stack.Pop());
                }
            }
        }

        /// <summary>
        /// Forces a context switch, so that objects are displayed in the UI thread
        /// </summary>
        public void DisplayResults()
        {
            try
            {
                halconWindow.BeginInvoke((MethodInvoker)delegate() { DisplayGraphicStack(); });
            }
            catch (HalconException hex)
            {
                MessageBox.Show(hex.GetErrorMessage(), "HALCON error",
                                MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
            catch (Exception ex)
            {
                MessageBox.Show(ex.ToString(), "System error",
                                MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        public void AddToStack(HObject obj)
        {
            lock (stack_lock)
            {
                graphic_stack.Push(obj);
            }
        }

        private void dashedToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (roi_object != null)
                roi_object.SetDrawingObjectParams(new HTuple("line_style"), new HTuple(20, 5));
        }

        private void continuousToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (roi_object != null)
                roi_object.SetDrawingObjectParams(new HTuple("line_style"), new HTuple());
        }

        private void Form1_MouseClick(object sender, MouseEventArgs e)
        {
            if (e.Button == System.Windows.Forms.MouseButtons.Right)
                contextMenuStrip1.Show(this, new Point(e.X, e.Y));
        }

        private void redToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (roi_object != null)
                roi_object.SetDrawingObjectParams("color", "red");
        }

        private void yellowToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (roi_object != null)
                roi_object.SetDrawingObjectParams("color", "yellow");
        }

        private void greenToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (roi_object != null)
                roi_object.SetDrawingObjectParams("color", "green");
        }

        private void blueToolStripMenuItem_Click(object sender, EventArgs e)
        {
            if (roi_object != null)
                roi_object.SetDrawingObjectParams("color", "blue");
        }

        private void halconWindow_MouseDown(object sender, MouseEventArgs e)
        {
            if (e.Button == System.Windows.Forms.MouseButtons.Right)
                contextMenuStrip1.Show(this, new Point(e.X, e.Y));
        }

        private void HALCONDialog_Resize(object sender, EventArgs e)
        {
            Control control = sender as Control;
            // resize only when the window is larger than the HALCON window
            HOperatorSet.SetSystem("flush_graphic", "false");
            if ((control.Height > 512) || (control.Width > 512))
            {
                halconWindow.Width = (int)(control.Width * width_ratio);
                halconWindow.Height = (int)(control.Height * height_ratio);
            }
            HOperatorSet.SetSystem("flush_graphic", "true");
            halconWindow.HalconWindow.DispCross(-10.0, -10.0, 5, 0.0);
            buttonRun.Location =
                new Point(buttonRun.Location.X,
                          halconWindow.Location.Y + halconWindow.Height + 10);
            buttonStop.Location =
                new Point(buttonStop.Location.X,
                          halconWindow.Location.Y + halconWindow.Height + 10);
            delayCheckBox.Location =
                new Point(delayCheckBox.Location.X,
                          halconWindow.Location.Y + halconWindow.Height + 30);
        }

        private void buttonRun_Click(object sender, EventArgs e)
        {
            createsbm.Stop();
            HShapeModel sbm = createsbm.GetShapeModel;
            if (sbm == null)
            {
                MessageBox.Show("You need to define a valid shape model first",
                    "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                createsbm.Start();
                return;
            }
            findsbm.ShapeModel = sbm;
            halconWindow.HalconWindow.DetachDrawingObjectFromWindow(roi_object);
            buttonStop.Enabled = true;
            buttonRun.Enabled = false;
            findsbm.Start();
            imggrabber.Start();
        }

        private void buttonStop_Click(object sender, EventArgs e)
        {
            imggrabber.Stop();
            findsbm.Stop();
            createsbm.Start();
            buttonStop.Enabled = false;
            buttonRun.Enabled = true;
            halconWindow.HalconWindow.AttachDrawingObjectToWindow(roi_object);
        }

        public HDrawingObject GetCurrentDrawingObject()
        {
            return roi_object;
        }

        #region IWorker Members

        public void AddMessage(HMessage objs)
        {
            HTuple finish = objs.GetMessageParam("key_exists", "finish_processing");
            if ((int)finish == 0)
            {
                HTuple hasmatch = objs.GetMessageParam("key_exists", "contour");
                if ((int)hasmatch == 1)
                    AddToStack(objs.GetMessageObj("contour"));
                AddToStack(objs.GetMessageObj("image"));
            }
            DisplayResults();

            // clean up previously sent HALCON objects
            GC.Collect();
            GC.WaitForPendingFinalizers();
        }

        #endregion

        private void HALCONDialog_FormClosed(object sender, FormClosedEventArgs e)
        {
            createsbm.Stop();
            findsbm.Stop();
            imggrabber.Stop();
        }


        /// <summary>
        /// Translate mouse coordinates with respect to the top left corner of HSmartWindowControl.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void my_MouseWheel(object sender, MouseEventArgs e)
        {
            Point pt = halconWindow.Location;
            MouseEventArgs newe = new MouseEventArgs(e.Button, e.Clicks, e.X - pt.X, e.Y - pt.Y, e.Delta);
            halconWindow.HSmartWindowControl_MouseWheel(sender, newe);
        }

    private void delayCheckBox_CheckedChanged(object sender, EventArgs e)
    {
      if (imggrabber == null)
        return;
      if (delayCheckBox.Checked)
          imggrabber.SlowMotion = true;
      else
          imggrabber.SlowMotion = false;
    }

    private void halconWindow_Load(object sender, EventArgs e)
        {
            this.MouseWheel += my_MouseWheel;
        }
    }
}
